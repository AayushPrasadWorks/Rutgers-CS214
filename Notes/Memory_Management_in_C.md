# Memory Management in C # 

## Introduction ##

When a program is loaded into memory, it is organized into three areas of memory, called segments:
* The text segment
* The stack segment
* The heap segment

The text segment
* aka code segment.
* is where the compiled code of the program itself resides.
* This is the machine language representation of the program steps to be carried out, including all functions making up the program, both user and system defined.

In general, an executable program generated by a compiler (like gcc) will have the following organization in memory on a typical architecture (like MIPS):



where:
* Code segment / text segment: Code segment contains the code executable or code binary.
* Data Segment: Sub-divided into two parts:
  * Initialized data segment: All the global, static, and constant data are stored in the data segment.
  * Uninitialized data segment: All the uninitialized data are stored in BSS.
* Heap: When program(s) allocate memory at runtime using calloc and malloc functions, then memory gets allocated in the heap. When some more memory needs to be allocated using calloc and malloc functions, the heap grows upward as shown in the above diagram.
* Stack: Stack is used to store local variables and is used for passing arguments to the functions along with the return address of the instruction which is to be executed after the function call is over. When a new stack frame needs to be added (as a result of a newly called function), the stack grows downward.

The stack and the heap are traditionally located at opposite ends of the process' virtual address space. 

The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with setrlimit(RLIMIT_STACK, â€¦)). 

The heap grows when the memory allocator invokes the brk() or sbrk() system call, mapping more pages of physical memory into the process' virtual address space.

Implementation of both the stack and heap is usually down to the runtime / OS.

## Stack ##

Stack: In computing architectures, stacks are regions of memory where data is added or removed in a last-in-first-out manner.

In most modern computer systems, each thread has a reserved region of memory referred to as its stack.

When a function executes, it may add some of its state data to the top of the stack. 

When the function exits, it is responsible for removing that data from the stack.

At minimum, a thread's stack is used to store the location of function calls in order to allow return statements to return to the correct location, but programmers may further choose to explicitly use the stack.

If a region of memory lies on the thread's stack, that memory is said to have been allocated on the stack.

Salient features of the stack:
* Because a stack follows a LIFO manner for adding/removing data, stack allocation is very simple and typically faster than heap-based memory allocation.
* Memory on the stack is automatically and very efficiently reclaimed whenever the function exits, which is very convenient for the programmer if the data is no longer required.
* However, if the data needs to be preserved or kept in some form, then it must be copied from the stack before the function exits.
* Thus, stack-based allocation is best for temporary data or data which is no longer required after the creating function exits.


